# Сервис Подключений Пользователей

Реализация тестового задания на позицию C# Backend Developer: сервис для приёма и обработки подключений пользователей по IP-адресам, с возможностью быстрого поиска и высокой устойчивостью к нагрузкам.

---

## Требования задания

- Принимать события подключения, содержащие `UserId` и `IpAddress`.
- Сохранять данные о последнем подключении пользователя по IP-адресу.
- Поддерживать поиск пользователей по полному или частичному IP-адресу.
- Позволять получить список всех IP-адресов пользователя.
- Позволять получить последний IP-адрес и время подключения пользователя.
- Позволять получить последнее подключение по любому IP-адресу.
- Гарантировать обработку событий даже при повторной доставке или сбоях сервиса.
- Обеспечивать поддержку IP-адресов формата IPv4 и IPv6.
- Выдерживать пиковую нагрузку в 50 000 подключений за 30 секунд.
- Минимизировать риск потери событий при высоких нагрузках.

---

## Пререквизиты для запуска сервиса

- .NET SDK 9.0 и выше
- PostgreSQL версии 14 и выше
- Docker (опционально, для контейнеризации и тестирования)
- Redis (опционально, если потребуется распределённая блокировка при масштабировании)

---

## Архитектура решения

### Структура проекта

- **Domain Layer** — бизнес-логика, сущности и правила (UserConnection и события).
- **Application Layer** — сценарии использования: команды и запросы через MediatR.
- **Infrastructure Layer** — доступ к базе данных через EF, работа с Outbox, фоновая обработка событий.
- **API Layer** — контроллеры для взаимодействия через REST.

### Почему сделано именно так

#### 1. Быстрая минимальная запись через Outbox
Когда приходит новое подключение, сервис:
- Не выполняет никаких проверок или сложных операций.
- Просто пишет событие в отдельную таблицу `ConnectionEventsOutbox`.
- Мгновенно отвечает клиенту, минимизируя нагрузку на сервер.

Это позволяет обрабатывать огромное количество подключений без риска упереться в лимиты по времени выполнения запроса или блокировки базы.
(В потенциале можно шардиродавть бд, по опр типу из самого айпи адреса)

#### 2. Фоновая асинхронная обработка событий
Отдельный фоновый процесс:
- Забирает события пакетами (batch size настраиваемый, например 500–1000 событий).
- Выполняет все проверки:
  - Ищет в `UserConnections` записи с данным `(UserId, IpAddress)`.
  - Если есть — обновляет время последнего подключения.
  - Если нет — вставляет новую запись.

Таким образом, основная база (`UserConnections`) никогда не блокируется лишними транзакциями на этапе приёма событий.

#### 3. Композитный первичный ключ `(UserId, IpAddress)`
В таблице `UserConnections` используется составной первичный ключ из `UserId` и `IpAddress`.

Это даёт:
- Естественное отражение бизнес-логики.
- Исключение необходимости в surrogate-ключах типа `Id`.
- Прямую работу без лишних JOIN и поиска по дополнительным полям.
- Уникальность связки `(UserId, IpAddress)` гарантируется самой базой.

#### 4. Индекс для поиска по префиксу IP
На колонку `IpAddress` создан индекс с использованием `text_pattern_ops`, чтобы:
- Выполнять быстрый поиск по частичному IP.
- Поддерживать требования задачи о нахождении пользователей по "началу" IP-адреса.

#### 5. Гарантия доставки событий
- Пока событие не обработано и не удалено из `ConnectionEventsOutbox`, оно остаётся в базе.
- Даже при сбоях фонового процесса или перезапуске сервиса события останутся и будут обработаны позже.

#### 6. Поддержка горизонтального масштабирования
- Можно поднимать несколько экземпляров сервиса для увеличения пропускной способности.
- Чтобы избежать гонок между инстансами при обработке одной и той же пачки событий, потребуется реализовать механизм распределённой блокировки (например, через Redlock на Redis).

